# Spring Boot Code Review Report

## 目錄

- [Review 基本資訊](#review-基本資訊)
- [問題摘要](#問題摘要)
- [嚴重問題](#嚴重問題-critical)
- [中等問題](#中等問題-warning)
- [輕微問題](#輕微問題-suggestion)
- [統計資訊](#統計資訊)
- [優點與亮點](#優點與亮點)
- [改善建議優先順序](#改善建議優先順序)
- [參考資源](#參考資源)

---

## Review 基本資訊

| 項目           | 內容                             |
| -------------- | -------------------------------- |
| **審查時間**   | 2026-02-06 14:30                 |
| **分支**       | issue_2180_api                   |
| **提交編號**   | 4d5730aa                         |
| **審查者**     | AI Reviewer                      |
| **變更檔案**   | 9 files                          |
| **程式碼行數** | +271 / -89                       |
| **審查範圍**   | Dynamic Material Release Feature |
| **提交作者**   | Peter Pan                        |

---

## 問題摘要

| 嚴重程度   | 數量   | 說明           |
| ---------- | ------ | -------------- |
| Critical   | 4      | 必須立即修正   |
| Warning    | 6      | 建議本週內修正 |
| Suggestion | 5      | 可排程改善     |
| **總計**   | **15** | -              |

---

## 嚴重問題 (Critical)

> **這些問題可能導致系統崩潰或資料錯誤，必須立即處理**

### Issue #1: NPE 風險 - releaseMaterial 方法中未檢查 null

**位置**: `DynamicMaterialServiceImpl.java:232-247`  
**類別**: Runtime Exception  
**嚴重性**: High

#### 問題程式碼

```java
List<MaterialAttachment> materialAttachments = materialAttachmentService
    .getAttachmentsByMaterialIdAndType(materialId, DYNAMIC_JSON_FILE_TYPES);
MaterialAttachment attachment = materialAttachments.stream()
    .filter(Objects::nonNull)
    .filter(att -> att.getFileName() != null)
    .filter(att -> Objects.equals(att.getFileType(), AttachmentTypeEnum.UNRELEASED_DYNAMIC_JSON.getCode()))
    .max(Comparator.comparingInt(att -> MaterialStringUtil.getAttachmentFileSerialNum(att.getFileName())))
    .orElse(null);
if (attachment == null) {
    log.error("No unpublished dynamic material config found for release, materialId: {}", materialId);
    vo.setMessage(StatusCodeEnum.CHECK_1310.getMsg());
    vo.setCode(StatusCodeEnum.CHECK_1310.getCode());
    return vo;
}
```

#### 問題說明

- `materialAttachmentService.getAttachmentsByMaterialIdAndType()` 可能回傳 `null`
- 直接對可能為 null 的物件呼叫 `.stream()` 會導致 `NullPointerException`
- **影響範圍**: 所有呼叫 releaseMaterial 的地方
- **風險等級**: High - 會直接造成 500 錯誤

#### 建議修正

```java
List<MaterialAttachment> materialAttachments = materialAttachmentService
    .getAttachmentsByMaterialIdAndType(materialId, DYNAMIC_JSON_FILE_TYPES);

// 先檢查 null 和 empty
if (CollectionUtils.isEmpty(materialAttachments)) {
    log.error("No dynamic material attachments found for release, materialId: {}", materialId);
    vo.setMessage(StatusCodeEnum.CHECK_1310.getMsg());
    vo.setCode(StatusCodeEnum.CHECK_1310.getCode());
    return vo;
}

MaterialAttachment attachment = materialAttachments.stream()
    .filter(Objects::nonNull)
    .filter(att -> att.getFileName() != null)
    .filter(att -> Objects.equals(att.getFileType(), AttachmentTypeEnum.UNRELEASED_DYNAMIC_JSON.getCode()))
    .max(Comparator.comparingInt(att -> MaterialStringUtil.getAttachmentFileSerialNum(att.getFileName())))
    .orElse(null);
```

#### 行動建議

- [ ] 在 stream 操作前檢查集合是否為 null 或 empty
- [ ] 檢查 `getAttachmentsByMaterialIdAndType` 的實作，確保回傳空 List 而非 null
- [ ] 添加單元測試覆蓋 null/empty 的情況

**參考資源**: [examples.md - NPE 風險處理](../examples.md#1-npe-風險處理)

---

### Issue #2: 業務邏輯錯誤 - 未檢查 upsertDynamicMaterial 執行結果

**位置**: `DynamicMaterialServiceImpl.java:220-226`  
**類別**: Business Logic  
**嚴重性**: High

#### 問題程式碼

```java
if (config != null && !config.isEmpty()) {
    UpsertDynamicMaterialReq upsertReq = new UpsertDynamicMaterialReq();
    upsertReq.setMaterialId(materialId);
    upsertReq.setConfig(config);
    upsertDynamicMaterial(upsertReq); // 沒有檢查回傳值
}
```

#### 問題說明

- 呼叫 `upsertDynamicMaterial()` 但沒有檢查回傳的 ResponseVO 是否成功
- 如果更新失敗，後續的發布動作仍會繼續執行
- 可能導致發布了錯誤版本的配置
- **影響範圍**: 資料一致性問題
- **風險等級**: High

#### 建議修正

```java
if (config != null && !config.isEmpty()) {
    UpsertDynamicMaterialReq upsertReq = new UpsertDynamicMaterialReq();
    upsertReq.setMaterialId(materialId);
    upsertReq.setConfig(config);
    ResponseVO upsertResult = upsertDynamicMaterial(upsertReq);

    // 檢查更新是否成功
    if (upsertResult == null || !upsertResult.isSuccess()) {
        log.error("Failed to upsert dynamic material before release, materialId: {}", materialId);
        return ResponseUtil.getFailure();
    }
}
```

#### 行動建議

- [ ] 檢查 upsert 操作的回傳值
- [ ] 失敗時應該立即返回，不繼續執行發布
- [ ] 考慮在 @Transactional 中一起回滾

---

### Issue #3: 重大邏輯變更 - MaterialStringUtil 解析邏輯改變

**位置**: `MaterialStringUtil.java:142-158`  
**類別**: Business Logic Change  
**嚴重性**: High

#### 問題程式碼

```java
// 舊邏輯：取最後一個下划線後的數字
int underscore = fileName.lastIndexOf('_');
int dot = fileName.lastIndexOf('.');
if (underscore < 0 || dot < 0 || underscore >= dot) {
    return 0;
}
String number = fileName.substring(underscore + 1, dot);

// 新邏輯：取第一個下划線後的數字
int underscore = fileName.indexOf('_');
if (underscore < 0 || underscore == fileName.length() - 1) {
    return 0;
}
int start = underscore + 1;
int end = start;
while (end < fileName.length() && Character.isDigit(fileName.charAt(end))) {
    end++;
}
```

#### 問題說明

- **重大行為變更**: 從解析最後一個下劃線改為第一個下劃線
- 舊檔名格式: `materialId_序號.json` → 新格式: `materialId_序號_時間戳.json`
- 此變更會影響所有依賴此方法的地方
- 可能導致舊格式檔案解析錯誤
- **相容性風險**: 資料庫中可能存在舊格式的檔案名稱

#### 範例說明

```
舊格式: "12345_3.json"        → 序號 = 3 ✓
新格式: "12345_3_1738836000000.json" → 序號 = 3 ✓
混合: "12345_old_3.json"      → 舊邏輯 = 3 ✓, 新邏輯 = 0 ✗
```

#### 建議修正

```java
public static int getAttachmentFileSerialNum(String fileName) {
    if (StringUtils.isBlank(fileName)) {
        return 0;
    }

    // 優先支援新格式: materialId_序號_時間戳.json
    // 同時相容舊格式: materialId_序號.json

    int firstUnderscore = fileName.indexOf('_');
    if (firstUnderscore < 0 || firstUnderscore == fileName.length() - 1) {
        return 0;
    }

    // 取第一個下劃線後的數字
    int start = firstUnderscore + 1;
    int end = start;
    while (end < fileName.length() && Character.isDigit(fileName.charAt(end))) {
        end++;
    }

    if (start == end) {
        return 0;
    }

    try {
        return Integer.parseInt(fileName.substring(start, end));
    } catch (NumberFormatException e) {
        log.warn("Failed to parse serial number from fileName: {}", fileName);
        return 0;
    }
}
```

#### 行動建議

- [ ] 確認現有資料庫中的檔案名稱格式
- [ ] 如果存在舊格式，需要資料遷移或雙重相容
- [ ] 添加單元測試覆蓋新舊格式
- [ ] 在變更說明中註明此為 Breaking Change

---

### Issue #4: Exception 處理過於廣泛

**位置**: `DynamicMaterialController.java:68-73`  
**類別**: Error Handling  
**嚴重性**: Medium-High

#### 問題程式碼

```java
@PostMapping("/releaseMaterial")
public ResponseVO releaseMaterial(@RequestBody UpsertDynamicMaterialReq req) {
    log.info("/dynamic-material/releaseMaterial");
    try {
        return dynamicMaterialService.releaseMaterial(req);
    } catch (Exception e) {
        log.error("Failed to release dynamic material, Exception:", e);
        return getFailure();
    }
}
```

#### 問題說明

- 捕獲所有 `Exception` 過於廣泛，會捕獲到不應該處理的異常（如 OutOfMemoryError）
- `getFailure()` 返回的是通用失敗訊息，使用者無法知道具體失敗原因
- Service 層已經有異常處理，Controller 不應該再捕獲
- **影響範圍**: API 錯誤訊息不明確，除錯困難
- **風險等級**: Medium-High

#### 建議修正

```java
@PostMapping("/releaseMaterial")
public ResponseVO releaseMaterial(@RequestBody UpsertDynamicMaterialReq req) {
    log.info("/dynamic-material/releaseMaterial, materialId: {}", req.getMaterialId());

    // 讓 Service 層的異常向上拋出，由統一的 ExceptionHandler 處理
    // 或者捕獲特定的業務異常
    try {
        return dynamicMaterialService.releaseMaterial(req);
    } catch (BusinessException e) {
        log.error("Failed to release dynamic material, materialId: {}, error: {}",
                  req.getMaterialId(), e.getMessage());
        return ResponseUtil.getFailure(e.getMessage());
    } catch (RuntimeException e) {
        log.error("System error when releasing dynamic material, materialId: {}",
                  req.getMaterialId(), e);
        return ResponseUtil.getFailure("系統錯誤，請稍後再試");
    }
}
```

#### 行動建議

- [ ] 定義業務異常類別，如 `MaterialNotFoundException`, `MaterialReleaseException`
- [ ] Service 層拋出具體的業務異常
- [ ] Controller 捕獲具體異常類型並返回明確的錯誤訊息
- [ ] 或使用全域的 `@ControllerAdvice` 統一處理異常

---

## 中等問題 (Warning)

> **這些問題影響可維護性或效能，建議盡快處理**

### Issue #5: 方法過長 - releaseMaterial 超過 60 行

**位置**: `DynamicMaterialServiceImpl.java:207-269`  
**類別**: Code Complexity  
**嚴重性**: Medium

#### 問題說明

- `releaseMaterial` 方法約 63 行，超過建議的 50 行
- 包含多個職責：參數驗證、更新配置、查詢附件、更新狀態、刪除舊版本
- 可讀性較差，不易維護

#### 建議修正

將方法拆分為多個子方法：

```java
@Override
@Transactional(rollbackFor = Exception.class)
public ResponseVO releaseMaterial(@RequestBody UpsertDynamicMaterialReq req) {
    // 1. 驗證參數
    ResponseVO validationResult = validateReleaseRequest(req);
    if (!validationResult.isSuccess()) {
        return validationResult;
    }

    // 2. 更新配置（如果有提供）
    if (req.getConfig() != null && !req.getConfig().isEmpty()) {
        ResponseVO upsertResult = updateMaterialConfig(req);
        if (!upsertResult.isSuccess()) {
            return upsertResult;
        }
    }

    // 3. 發布最新版本
    MaterialAttachment unreleasedAttachment = findLatestUnreleasedAttachment(req.getMaterialId());
    if (unreleasedAttachment == null) {
        return ResponseUtil.getFailure(StatusCodeEnum.CHECK_1310);
    }

    // 4. 更新為已發布狀態
    publishAttachment(unreleasedAttachment);

    // 5. 刪除其他版本
    deleteOtherVersions(req.getMaterialId(), unreleasedAttachment.getId());

    return ResponseUtil.getSuccess();
}

private MaterialAttachment findLatestUnreleasedAttachment(Long materialId) {
    List<MaterialAttachment> attachments = materialAttachmentService
        .getAttachmentsByMaterialIdAndType(materialId, DYNAMIC_JSON_FILE_TYPES);

    if (CollectionUtils.isEmpty(attachments)) {
        return null;
    }

    return attachments.stream()
        .filter(Objects::nonNull)
        .filter(att -> att.getFileName() != null)
        .filter(att -> Objects.equals(att.getFileType(),
                AttachmentTypeEnum.UNRELEASED_DYNAMIC_JSON.getCode()))
        .max(Comparator.comparingInt(att ->
                MaterialStringUtil.getAttachmentFileSerialNum(att.getFileName())))
        .orElse(null);
}
```

#### 行動建議

- [ ] 提取子方法，每個方法只做一件事
- [ ] 改善命名，讓方法名稱清楚表達意圖
- [ ] 減少巢狀層級

---

### Issue #6: Transaction 內部呼叫外部方法可能失效

**位置**: `DynamicMaterialServiceImpl.java:220-226`  
**類別**: Transaction Management  
**嚴重性**: Medium

#### 問題說明

- `releaseMaterial` 方法有 `@Transactional` 註解
- 內部呼叫了 `upsertDynamicMaterial(req)` 方法
- 如果 `upsertDynamicMaterial` 失敗，不會回滾 `releaseMaterial` 的後續操作
- Transaction 傳播機制可能不符合預期

#### 建議修正

```java
@Override
@Transactional(rollbackFor = Exception.class)
public ResponseVO releaseMaterial(@RequestBody UpsertDynamicMaterialReq req) {
    // ...
    if (config != null && !config.isEmpty()) {
        // 檢查回傳值，失敗時拋出異常讓整個 transaction 回滾
        ResponseVO upsertResult = upsertDynamicMaterial(upsertReq);
        if (upsertResult == null || !upsertResult.isSuccess()) {
            throw new MaterialUpdateException("Failed to update material config before release");
        }
    }
    // ...
}
```

#### 行動建議

- [ ] 確認 Transaction 傳播機制設定
- [ ] 失敗時拋出 RuntimeException 觸發回滾
- [ ] 添加整合測試驗證事務行為

---

### Issue #7: 介面方法簽名變更影響範圍廣

**位置**: `IMaterialAttachmentService.java:57-60`  
**類別**: API Breaking Change  
**嚴重性**: Medium

#### 問題說明

- `getLatestAttachmentByFileType` 參數從 `Integer fileType` 改為 `List<Integer> fileTypes`
- `getAttachmentsByMaterialIdAndType` 也有同樣的變更
- **Breaking Change**: 所有呼叫方都需要修改
- 從 diff 看只修改了此次需要的呼叫，可能遺漏其他呼叫方

#### 建議修正方案一：保留舊方法，新增多型方法

```java
// 保留舊方法，避免 Breaking Change
MaterialAttachment getLatestAttachmentByFileType(Long materialId, Integer fileType);

// 新增多型方法
MaterialAttachment getLatestAttachmentByFileTypes(Long materialId, List<Integer> fileTypes);

// 或使用預設實作
default MaterialAttachment getLatestAttachmentByFileType(Long materialId, Integer fileType) {
    return getLatestAttachmentByFileTypes(materialId, Collections.singletonList(fileType));
}
```

#### 建議修正方案二：全域搜尋並修改所有呼叫

```bash
# 搜尋所有呼叫此方法的地方
grep -r "getLatestAttachmentByFileType" --include="*.java"
grep -r "getAttachmentsByMaterialIdAndType" --include="*.java"
```

#### 行動建議

- [ ] 搜尋所有呼叫方並一併修改
- [ ] 或使用方法多載保持向後相容
- [ ] 更新 API 文件說明此變更
- [ ] 考慮使用 `@Deprecated` 標記舊方法

---

### Issue #8: 檔案命名格式改變但缺乏說明

**位置**: `DynamicMaterialServiceImpl.java:159`  
**類別**: Documentation & Compatibility  
**嚴重性**: Medium

#### 問題程式碼

```java
// 舊格式
String newFileName = materialId + "_" + serialNum + JSON_FILE_EXTENSION;

// 新格式
String newFileName = materialId + "_" + serialNum + "_" + System.currentTimeMillis() + JSON_FILE_EXTENSION;
```

#### 問題說明

- 檔案命名格式從 `{materialId}_{serialNum}.json` 改為 `{materialId}_{serialNum}_{timestamp}.json`
- 新增了時間戳，但缺乏註解說明原因
- 可能造成相容性問題：舊系統可能依賴舊格式解析
- 時間戳的用途不明確（防重複？版本標記？）

#### 建議修正

```java
// 產生唯一的檔案名稱
// 格式: {materialId}_{serialNum}_{timestamp}.json
// timestamp 用於確保檔案名稱唯一性，避免並發更新時的檔名衝突
String newFileName = String.format("%d_%d_%d%s",
    materialId,
    serialNum,
    System.currentTimeMillis(),
    JSON_FILE_EXTENSION
);
```

#### 行動建議

- [ ] 添加註解說明新格式的目的
- [ ] 確認是否需要支援舊格式的讀取
- [ ] 考慮使用常數定義檔名格式
- [ ] 更新相關文件

---

### Issue #9: 序號生成邏輯複雜且容易出錯

**位置**: `DynamicMaterialServiceImpl.java:148-163`  
**類別**: Code Complexity  
**嚴重性**: Medium

#### 問題程式碼

```java
MaterialAttachment oldAttachment = materialAttachmentService.getLatestAttachmentByFileType(materialId, DYNAMIC_JSON_FILE_TYPES);
int serialNum = 1;
// 是否覆蓋未發佈版本
boolean isOverwriteUnreleased = false;
if (oldAttachment != null) {
    serialNum = MaterialStringUtil.getAttachmentFileSerialNum(oldAttachment.getFileName());
    // 如果是已發佈的版本，則序號+1
    if (Objects.equals(oldAttachment.getFileType(), AttachmentTypeEnum.RELEASED_DYNAMIC_JSON.getCode())) {
        serialNum++;
    } else {
        // 未發佈版本則直接覆蓋
        isOverwriteUnreleased = true;
    }
}
```

#### 問題說明

- 序號生成規則：
  - 如果最新版本是已發佈 → 序號 +1
  - 如果最新版本是未發佈 → 覆蓋（序號不變）
- 邏輯分散在多個地方，不易理解
- `isOverwriteUnreleased` 命名不夠直觀
- 沒有處理並發情況下的序號衝突

#### 建議修正

```java
// 提取為獨立方法，提高可讀性
private SerialNumberInfo calculateSerialNumber(Long materialId) {
    MaterialAttachment latestAttachment = materialAttachmentService
        .getLatestAttachmentByFileType(materialId, DYNAMIC_JSON_FILE_TYPES);

    if (latestAttachment == null) {
        return new SerialNumberInfo(1, false, null);
    }

    int currentSerial = MaterialStringUtil.getAttachmentFileSerialNum(
        latestAttachment.getFileName()
    );

    boolean isLatestReleased = Objects.equals(
        latestAttachment.getFileType(),
        AttachmentTypeEnum.RELEASED_DYNAMIC_JSON.getCode()
    );

    if (isLatestReleased) {
        // 已發佈版本 → 建立新版本
        return new SerialNumberInfo(currentSerial + 1, false, null);
    } else {
        // 未發佈版本 → 覆蓋現有版本
        return new SerialNumberInfo(currentSerial, true, latestAttachment);
    }
}

// 內部類別，封裝序號資訊
@Data
private static class SerialNumberInfo {
    private final int serialNumber;
    private final boolean shouldOverwrite;
    private final MaterialAttachment attachmentToOverwrite;
}
```

#### 行動建議

- [ ] 提取為獨立方法
- [ ] 使用物件封裝返回值
- [ ] 添加單元測試覆蓋各種情況
- [ ] 考慮並發安全性（樂觀鎖或悲觀鎖）

---

### Issue #10: 刪除操作使用軟刪除但缺乏驗證

**位置**: `MaterialAttachmentServiceImpl.java:905-914`  
**類別**: Data Integrity  
**嚴重性**: Medium

#### 問題程式碼

```java
@Override
public void deleteByIds(List<Long> ids) {
    if (CollectionUtils.isEmpty(ids)) {
        return;
    }
    MaterialAttachment entity = new MaterialAttachment();
    entity.setIsDel(IsDelEnum.IS_DEL_Y.getCode());
    update(entity, new EntityWrapper<MaterialAttachment>()
        .in("id", ids)
        .eq("is_del", IsDelEnum.IS_DEL_N.getCode()));
}
```

#### 問題說明

- `update()` 方法沒有回傳值檢查
- 不確定是否成功刪除（可能 ids 不存在或已被刪除）
- 呼叫方無法得知操作結果
- 沒有記錄被刪除的資料（日誌或審計）

#### 建議修正

```java
@Override
public void deleteByIds(List<Long> ids) {
    if (CollectionUtils.isEmpty(ids)) {
        log.warn("deleteByIds called with empty ids list");
        return;
    }

    log.info("Soft deleting material attachments, ids: {}", ids);

    MaterialAttachment entity = new MaterialAttachment();
    entity.setIsDel(IsDelEnum.IS_DEL_Y.getCode());
    entity.setModifiedAt(new Date());

    boolean success = update(entity, new EntityWrapper<MaterialAttachment>()
        .in("id", ids)
        .eq("is_del", IsDelEnum.IS_DEL_N.getCode()));

    if (!success) {
        log.error("Failed to soft delete material attachments, ids: {}", ids);
        throw new DataUpdateException("Failed to delete attachments");
    }

    log.info("Successfully soft deleted {} material attachments", ids.size());
}
```

#### 行動建議

- [ ] 檢查更新結果
- [ ] 失敗時拋出異常或回傳錯誤
- [ ] 添加日誌記錄刪除操作
- [ ] 設定 `modified_at` 欄位

---

## 輕微問題 (Suggestion)

> **這些是程式碼風格或可讀性建議，可排程改善**

### Issue #11: Import 語句過多影響可讀性

**位置**: `MaterialAttachmentServiceImpl.java:7-45`  
**類別**: Code Style  
**嚴重性**: Low

#### 問題說明

- imports 從使用萬用字元改為逐一導入
- 增加了大量 import 語句（約 30+ 行）
- 雖然更明確但影響可讀性
- IDE 通常建議超過 5 個同 package 的 import 使用萬用字元

#### 建議修正

```java
// 建議使用萬用字元
import com.vipabc.material.common.enums.*;
import com.vipabc.material.entity.*;
import com.vipabc.material.mapper.mat.*;

// 或使用 IDE 的 optimize imports 功能
```

#### 行動建議

- [ ] 使用 IDE 的 "Optimize Imports" 功能
- [ ] 統一團隊的 import 規範
- [ ] 設定 IDE 的 import 優化規則

---

### Issue #12: Magic String 應提取為常數

**位置**: `DynamicMaterialServiceImpl.java:159`  
**類別**: Code Maintainability  
**嚴重性**: Low

#### 問題程式碼

```java
String newFileName = materialId + "_" + serialNum + "_" + System.currentTimeMillis() + JSON_FILE_EXTENSION;
```

#### 建議修正

```java
// 提取格式字串為常數
private static final String DYNAMIC_JSON_FILENAME_FORMAT = "%d_%d_%d%s";

// 使用
String newFileName = String.format(
    DYNAMIC_JSON_FILENAME_FORMAT,
    materialId,
    serialNum,
    System.currentTimeMillis(),
    JSON_FILE_EXTENSION
);
```

---

### Issue #13: 缺少單元測試

**位置**: 所有變更的檔案  
**類別**: Test Coverage  
**嚴重性**: Medium

#### 問題說明

- 新增的核心功能缺少單元測試
- 關鍵方法應該測試：
  - `releaseMaterial()` 的各種情況
  - `MaterialStringUtil.getAttachmentFileSerialNum()` 的新舊格式
  - 序號生成邏輯
  - 邊界情況處理

#### 建議新增測試

```java
@Test
public void testReleaseMaterial_Success() {
    // 測試正常發布流程
}

@Test
public void testReleaseMaterial_NoUnreleasedVersion() {
    // 測試沒有未發佈版本的情況
}

@Test
public void testGetAttachmentFileSerialNum_NewFormat() {
    // 測試新格式: "12345_3_1738836000000.json"
    assertEquals(3, MaterialStringUtil.getAttachmentFileSerialNum("12345_3_1738836000000.json"));
}

@Test
public void testGetAttachmentFileSerialNum_OldFormat() {
    // 測試舊格式相容性: "12345_3.json"
    assertEquals(3, MaterialStringUtil.getAttachmentFileSerialNum("12345_3.json"));
}
```

#### 行動建議

- [ ] 為新增的功能添加單元測試
- [ ] 測試邊界情況和異常情況
- [ ] 確保測試覆蓋率 > 80%

---

### Issue #14: 日誌層級使用不當

**位置**: 多處  
**類別**: Logging  
**嚴重性**: Low

#### 問題說明

- `DynamicMaterialController.java:68` 使用 `log.info` 記錄所有請求
- 應該使用 `log.debug` 或只記錄關鍵參數
- 生產環境會產生大量日誌

#### 建議修正

```java
// Before
log.info("/dynamic-material/releaseMaterial");

// After
log.info("Release dynamic material request, materialId: {}", req.getMaterialId());
// 或
log.debug("Received release material request: {}", req);
```

---

### Issue #15: Enum 命名變更缺乏向下相容

**位置**: `AttachmentTypeEnum.java:24-25`  
**類別**: API Compatibility  
**嚴重性**: Low

#### 問題程式碼

```java
// Before
DYNAMIC_JSON_CONFIG(15, "dynamic_json_config");

// After
UNRELEASED_DYNAMIC_JSON(15, "unrelease_dynamic_json"),
RELEASED_DYNAMIC_JSON(16, "release_dynamic_json");
```

#### 問題說明

- 移除了 `DYNAMIC_JSON_CONFIG` 枚舉值
- 如果其他地方還在使用會編譯錯誤
- code 為 15 的值語意改變了

#### 建議修正

```java
// 保留舊值並標記為過時
@Deprecated
DYNAMIC_JSON_CONFIG(15, "dynamic_json_config"),
UNRELEASED_DYNAMIC_JSON(15, "unrelease_dynamic_json"), // 與舊值 code 相同
RELEASED_DYNAMIC_JSON(16, "release_dynamic_json");
```

或者進行資料遷移：

```sql
-- 將舊的 fileType=15 的資料更新為未發佈狀態
UPDATE material_attachment
SET file_type = 15 -- UNRELEASED_DYNAMIC_JSON
WHERE file_type = 15 -- 舊的 DYNAMIC_JSON_CONFIG
AND is_del = 0
```

#### 行動建議

- [ ] 檢查是否還有使用 `DYNAMIC_JSON_CONFIG` 的地方
- [ ] 使用 `@Deprecated` 標記並提供遷移指引
- [ ] 或進行資料遷移確保一致性

---

## 統計資訊

### 程式碼複雜度

| 檔案                               | 新增行數 | 刪除行數 | 複雜度評分 |
| ---------------------------------- | -------- | -------- | ---------- |
| DynamicMaterialServiceImpl.java    | +127     | -34      | High       |
| MaterialAttachmentServiceImpl.java | +44      | -13      | Medium     |
| DynamicMaterialController.java     | +17      | 0        | Low        |
| MaterialStringUtil.java            | +9       | -7       | Medium     |
| 其他                               | +74      | -35      | Low        |
| **總計**                           | **+271** | **-89**  | -          |

### 風險評估矩陣

| 風險類別     | 數量 | 風險指數 |
| ------------ | ---- | -------- |
| NPE 風險     | 2    | High     |
| 業務邏輯錯誤 | 2    | High     |
| 架構設計問題 | 3    | Medium   |
| 效能問題     | 0    | Low      |
| 安全性問題   | 0    | Low      |
| 測試覆蓋不足 | 1    | Medium   |
| **總體風險** | -    | **High** |

### 受影響的模組

- Controller: DynamicMaterialController
- Service: DynamicMaterialService, MaterialAttachmentService
- Util: MaterialStringUtil
- Enum: AttachmentTypeEnum, StatusCodeEnum
- Entity: GetDynamicMaterialRsp

---

## 優點與亮點

### 做得好的地方

1. **功能設計合理**
   - 區分已發布和未發布版本的設計思路清晰
   - 版本管理機制完善（序號 + 時間戳）

2. **事務管理**
   - 使用 `@Transactional` 確保資料一致性
   - 軟刪除機制保留歷史資料

3. **日誌記錄**
   - 關鍵流程都有日誌記錄
   - 錯誤訊息包含必要的上下文資訊

4. **程式碼風格**
   - 使用 Stream API 處理集合
   - 使用 Optional 處理可能為空的值
   - 常數提取（如 `DYNAMIC_JSON_FILE_TYPES`）

5. **向後相容考量**
   - 保留了舊格式檔案的解析能力（修正後）
   - 使用軟刪除而非硬刪除

---

## 改善建議優先順序

### P0 - 立即修正（本週內）

1. **Issue #1**: NPE 風險 - 添加 null 檢查
2. **Issue #2**: 檢查 upsertDynamicMaterial 回傳值
3. **Issue #3**: 確認 MaterialStringUtil 邏輯變更的相容性
4. **Issue #4**: 改善 Exception 處理機制

### P1 - 重要（兩週內）

5. **Issue #5**: 重構 releaseMaterial 方法，拆分職責
6. **Issue #7**: 確認介面變更的影響範圍
7. **Issue #9**: 簡化序號生成邏輯
8. **Issue #13**: 添加單元測試

### P2 - 一般（一個月內）

9. **Issue #6**: 檢查 Transaction 傳播機制
10. **Issue #8**: 添加檔案命名格式說明
11. **Issue #10**: 改善刪除操作的錯誤處理
12. **Issue #15**: 處理 Enum 變更的相容性

### P3 - 優化（可排程）

13. **Issue #11**: 優化 Import 語句
14. **Issue #12**: 提取 Magic String
15. **Issue #14**: 調整日誌層級

---

## 參考資源

### 內部文件

- [Code Review Checklist](../checklist.md)
- [Good/Bad Examples](../examples.md)
- [Writing Style Guide](../writing-style.md)

### 外部資源

- [Effective Java - Item 54: Return empty collections or arrays, not nulls](https://www.oreilly.com/library/view/effective-java/9780134686097/)
- [Spring Transaction Management](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction)
- [MyBatis Best Practices](https://mybatis.org/mybatis-3/java-api.html)

### 建議閱讀

- **NPE 處理**: [Java 8 Optional 最佳實踐](https://www.baeldung.com/java-optional)
- **Exception 處理**: [Spring Boot 全域異常處理](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc)
- **Transaction 管理**: [Understanding Spring @Transactional](https://www.baeldung.com/transaction-configuration-with-spring-and-jpa)

---

## 總結

本次 Code Review 發現 **15 個問題**，其中 **4 個嚴重問題**需要立即處理。主要關注點：

1. **NPE 風險**: 多處缺少 null 檢查，需要補強
2. **業務邏輯**: 需要檢查操作結果並正確處理失敗情況
3. **向後相容**: 邏輯變更和 API 變更需要確保相容性
4. **測試覆蓋**: 缺少單元測試，建議補充

整體而言，這次的功能實作思路清晰，但在錯誤處理和邊界情況的考慮上還有改善空間。建議優先處理 P0 和 P1 的問題後再進行合併。

---

**審查完成時間**: 2026-02-06 14:30  
**下次審查建議**: 修正完成後進行第二次 Review
